package com.guerzonica.app.storage.models;

import java.lang.reflect.Type;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;

import com.guerzonica.app.channel.interfaces.Streammable;
import com.guerzonica.app.channel.models.Packet;
import com.guerzonica.app.storage.Storage;
import com.guerzonica.app.storage.exceptions.AlreadyExistException;
import com.guerzonica.app.storage.exceptions.NotFoundException;

/**
 * Model of a price Offer.
 * <br>
 * The model extends the base class Item and then implements the minimal
 * methods that garantee a working CRUD logic on the Database
 * <br>
 * The model takes advantage of java xml annotations bindings to parse 
 * the XML data provided by Amazon after the Http Request
 * <br>
 * The model implements the Streammable interface to be serialized
 * in a Packet format and then sended to other peers using a Channel
 * <br> 
 * The model takes advantage of SerializedName annotation to parse
 * or stringify the data to a JSON Object
 * 
 * @author Matteo Guerzoni
 * 
 * @see com.guerzonica.app.channel.Channel Channel
 */
@XmlRootElement
public class Offer extends Item<Integer> implements Streammable {

    /** Specifies the date format (dd/MM/yyyy) */
    public static final SimpleDateFormat Format =
        new SimpleDateFormat("dd/MM/yyyy");

    /** Specifies the database table name */
    public static final String tableName = "offers";

    /** The referred price date */
    @SerializedName(value="date")
    private String date;

    /** The referred price value */
    @SerializedName(value="price")
    private Float price;

    /** The referred Product */
    private Product product;

    /** 
     * Parse the price value.
     * 
     * @param offer A String value representing the price without decimals
     */
    @XmlElement
    public void setValue(String offer) {

        Date now = new Date();
        Number currency = Float.parseFloat(offer) / 100;
        
        this.date  = Format.format(now);
        this.price = currency.floatValue();
    }

    /** 
     * Returns the date formatted to unix timestamp.
     * 
     * @throws ParseException If the date is not in a valid format
     * 
     * @return Value representing the date value as unix timestamp
     */
    public Long getUnixDate() throws ParseException {
        return Format.parse(this.getDate()).getTime();
    }
    
    public Float getPrice() {
        return this.price;
    }

    public void setPrice(Float price) {
        this.price = price;
    }

    public String getDate() {
        return this.date;
    }

    public void setDate(String date) {
        this.date = date;
    }

    public Product getProduct() {
        return this.product;
    }

    /** 
     * Parse the XML Product value
     * 
     * @param product The parsed Product
     */
    @XmlElement
    public void setProduct(Product product) {
        this.product = product;
    }

    public static Type typeToken() {
        return new TypeToken<Packet<Offer>>() {}.getType();
    }

    public static void SCHEMA() throws SQLException {

        Statement statement = Storage.getConnection().createStatement();

            statement.execute(
                "CREATE TABLE if not exists " + tableName + "( "
                    + "id integer, "
                    + "date varchar(60), "
                    + "price real, "
                    + "product varchar(10) references products(id), "
                    + "primary key(id), "
                    + "unique(product, date) "
                + ");"
            );
    }

    public void CREATE() throws AlreadyExistException, SQLException {
        PreparedStatement statement = Storage.getConnection()
            .prepareStatement("INSERT INTO " + tableName + " VALUES (?,?,?,?);");

            // autogenerated
            // statement.setInt(   1, this.getId());
            statement.setString(2, this.date);
            statement.setFloat( 3, this.price);
            statement.setString(4, this.product.getId());

        statement.execute();

        Statement getId = Storage.getConnection().createStatement();
        ResultSet value = getId.executeQuery("SELECT last_insert_rowid()");

            value.next();
        
        this.setId(value.getInt(1));
    }

    public void READ(ResultSet offer) throws NotFoundException, SQLException {

        if(offer.isClosed())
            throw new NotFoundException(this.getId().toString());

        this.setId(offer.getInt("id"));

        Product product = new Product();
            product.setAsin(offer.getString("product"));

        this.price = offer.getFloat("price");
        this.date  = offer.getString("date");

        this.product = product;

    }

    public void READ() throws NotFoundException, SQLException {
        Statement statement = Storage.getConnection().createStatement();
        ResultSet content   = statement.executeQuery("SELECT * FROM " + tableName + " where id = " + this.getId());
            content.first();

        this.READ(content);
        product.READ();
    }

    public void UPDATE() throws NotFoundException, SQLException {
        throw new SQLException("Cannot update value");
    }

    public void DELETE() throws NotFoundException, SQLException {
        Statement statement  = Storage.getConnection().createStatement();
            statement.execute("DELETE FROM " + tableName + " WHERE id = " + this.getId());
    }

}